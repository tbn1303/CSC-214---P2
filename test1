#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <ctype.h>
#include <sys/stat.h>

#define MAX_WORDS 100000
#define MAX_DICT_SIZE 1000000
#define WORD_LEN 128
#define PATH_LEN 1024
#define BUFSIZE 256

char *suffix = ".txt";

// -------------------- LINES STRUCT --------------------
typedef struct {
    char *buf;
    int pos;
    int bytes;
    int fd;
} LINES;

void lines_init(LINES *l, int fd) {
    l->buf = malloc(BUFSIZE);
    l->pos = 0;
    l->bytes = 0;
    l->fd = fd;
}

void lines_destroy(LINES *l) {
    free(l->buf);
}

char *lines_next(LINES *l) {
    char *line = NULL;
    int linelen = 0;

    if (l->bytes < 0)
        return NULL;

    do {
        int segstart = l->pos;
        while (l->pos < l->bytes) {
            if (l->buf[l->pos] == '\n') {
                int seglen = l->pos - segstart;
                line = realloc(line, linelen + seglen + 1);
                memcpy(line + linelen, l->buf + segstart, seglen);
                line[linelen + seglen] = '\0';
                l->pos++;
                return line;
            }
            l->pos++;
        }

        if (segstart < l->pos) {
            int seglen = l->pos - segstart;
            line = realloc(line, linelen + seglen + 1);
            memcpy(line + linelen, l->buf + segstart, seglen);
            linelen += seglen;
            line[linelen] = '\0';
        }

        l->pos = 0;
        l->bytes = read(l->fd, l->buf, BUFSIZE);
    } while (l->bytes > 0);

    l->bytes = -1;
    return line;
}

// -------------------- DICTIONARY --------------------
char *load_dict(const char *path) {
    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        perror("open dictionary");
        exit(EXIT_FAILURE);
    }

    char *buf = malloc(MAX_DICT_SIZE);
    if (!buf) {
        perror("malloc dictionary");
        close(fd);
        exit(EXIT_FAILURE);
    }

    ssize_t bytes = read(fd, buf, MAX_DICT_SIZE - 1);
    if (bytes < 0) {
        perror("read dictionary");
        free(buf);
        close(fd);
        exit(EXIT_FAILURE);
    }

    buf[bytes] = '\0';
    close(fd);
    return buf;
}

int split_dict(char *buf, char *dict[]) {
    int n = 0;
    char *tok = strtok(buf, "\n");
    while (tok && n < MAX_WORDS) {
        dict[n++] = tok;
        tok = strtok(NULL, "\n");
    }
    return n;
}

// -------------------- MATCHING RULES --------------------
int match_word(const char *input, const char *dict_word) {
    int has_upper = 0;
    for (int i = 0; dict_word[i]; i++) {
        if (isupper(dict_word[i])) {
            has_upper = 1;
            break;
        }
    }

    if (!has_upper) {
        // dictionary word all lowercase: accept any capitalization
        return strcasecmp(input, dict_word) == 0;
    }

    // dictionary has uppercase letters: must match exactly or be all uppercase
    if (strcmp(input, dict_word) == 0)
        return 1;

    int all_caps = 1;
    for (int i = 0; input[i]; i++) {
        if (isalpha(input[i]) && !isupper(input[i])) {
            all_caps = 0;
            break;
        }
    }

    if (all_caps && strcasecmp(input, dict_word) == 0)
        return 1;

    return 0;
}

int in_dict(const char *word, char *dict[], int n) {
    for (int i = 0; i < n; i++)
        if (match_word(word, dict[i]))
            return 1;
    return 0;
}

// -------------------- CHECK HELPERS --------------------
int check_valid_word(const char *word) {
    for (int i = 0; word[i]; i++) {
        if (isalpha(word[i]))
            return 1;
    }
    return 0;
}

// -------------------- CHECK FILE --------------------
int check_fd(const char *path, int fd, char *dict[], int n) {
    LINES lines;
    lines_init(&lines, fd);

    char *line;
    int line_num = 1;
    int err = 0;

    while ((line = lines_next(&lines))) {
        int col = 1;
        int i = 0;
        char word[WORD_LEN];

        for (int pos = 0; line[pos]; pos++, col++) {
            char ch = line[pos];

            if (isspace(ch)) {
                if (i > 0) {
                    word[i] = '\0';
                    int start = 0;
                    while (word[start] && ispunct(word[start])) start++;
                    int end = strlen(word) - 1;
                    while (end >= start && ispunct(word[end])) end--;
                    word[end + 1] = '\0';

                    if (start <= end) {
                        char *clean = word + start;
                        if (check_valid_word(clean) && !in_dict(clean, dict, n)) {
                            printf("%s:%d:%d %s\n", path, line_num, col - i, clean);
                            err = 1;
                        }
                    }
                    i = 0;
                }
            } else {
                if (i < WORD_LEN - 1)
                    word[i++] = ch;
            }
        }

        // handle last word on line
        if (i > 0) {
            word[i] = '\0';
            int start = 0;
            while (word[start] && ispunct(word[start])) start++;
            int end = strlen(word) - 1;
            while (end >= start && ispunct(word[end])) end--;
            word[end + 1] = '\0';

            if (start <= end) {
                char *clean = word + start;
                if (check_valid_word(clean) && !in_dict(clean, dict, n)) {
                    printf("%s:%d:%d %s\n", path, line_num, col - i, clean);
                    err = 1;
                }
            }
        }

        free(line);
        line_num++;
    }

    lines_destroy(&lines);
    return err;
}

// -------------------- DIRECTORY RECURSION --------------------
int has_suffix(const char *filename) {
    size_t len = strlen(filename);
    size_t suf_len = strlen(suffix);
    return len >= suf_len && strcmp(filename + len - suf_len, suffix) == 0;
}

int check_dir(const char *dir, char *dict[], int n) {
    DIR *d = opendir(dir);
    if (!d) {
        perror(dir);
        return 1;
    }

    struct dirent *ent;
    struct stat st;
    char path[PATH_LEN];
    int err = 0;

    while ((ent = readdir(d))) {
        if (!strcmp(ent->d_name, ".") || !strcmp(ent->d_name, ".."))
            continue;

        snprintf(path, sizeof(path), "%s/%s", dir, ent->d_name);
        if (stat(path, &st) == -1)
            continue;

        if (S_ISDIR(st.st_mode))
            err |= check_dir(path, dict, n);
        else if (S_ISREG(st.st_mode) && has_suffix(ent->d_name)) {
            int fd = open(path, O_RDONLY);
            if (fd < 0) {
                perror(path);
                continue;
            }
            err |= check_fd(path, fd, dict, n);
            close(fd);
        }
    }

    closedir(d);
    return err;
}

// -------------------- MAIN --------------------
int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s [-s suffix] <dictionary> [file|directory]\n", argv[0]);
        return EXIT_FAILURE;
    }

    int argi = 1;
    if (argc > 2 && strcmp(argv[1], "-s") == 0) {
        suffix = argv[2];
        argi = 3;
    }

    char *buf = load_dict(argv[argi]);
    char *dict[MAX_WORDS];
    int n = split_dict(buf, dict);

    int err = 0;
    if (argc <= argi + 1)
        err = check_fd("stdin", STDIN_FILENO, dict, n);
    else {
        struct stat st;
        if (stat(argv[argi + 1], &st) == -1) {
            perror(argv[argi + 1]);
            free(buf);
            return EXIT_FAILURE;
        }

        if (S_ISDIR(st.st_mode))
            err = check_dir(argv[argi + 1], dict, n);
        else {
            int fd = open(argv[argi + 1], O_RDONLY);
            if (fd < 0) {
                perror(argv[argi + 1]);
                free(buf);
                return EXIT_FAILURE;
            }
            err = check_fd(argv[argi + 1], fd, dict, n);
            close(fd);
        }
    }

    free(buf);
    return err ? EXIT_FAILURE : EXIT_SUCCESS;
}
