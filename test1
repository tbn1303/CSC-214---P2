#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>

#define TOTAL_WORDS 100000
#define BUFSIZE 256
#define WORDLEN 128

typedef struct {
    char *buf;
    int fd;
    int pos;
    int bytes;
} LINES;

// Initialize LINES structure
void lines_init(LINES *l, int fd) {
    l->buf = malloc(BUFSIZE);
    l->pos = 0;
    l->bytes = 0;
    l->fd = fd;
}

// Destroy LINES structure
void lines_destroy(LINES *l) {
    free(l->buf);
}

// Read next line using read()
char *lines_next(LINES *l) {
    char *line = NULL;
    int linelen = 0;

    if (l->bytes < 0) return NULL;

    do {
        int segstart = l->pos;
        while (l->pos < l->bytes) {
            if (l->buf[l->pos] == '\n') {
                int seglen = l->pos - segstart;
                line = realloc(line, linelen + seglen + 1);
                memcpy(line + linelen, l->buf + segstart, seglen);
                line[linelen + seglen] = '\0';
                l->pos++;
                return line;
            }
            l->pos++;
        }
        if (segstart < l->pos) {
            int seglen = l->pos - segstart;
            line = realloc(line, linelen + seglen + 1);
            memcpy(line + linelen, l->buf + segstart, seglen);
            linelen += seglen;
            line[linelen] = '\0';
        }
        l->pos = 0;
        l->bytes = read(l->fd, l->buf, BUFSIZE);
    } while (l->bytes > 0);

    l->bytes = -1;
    return line;
}

// Read dictionary into buffer
char *dictionary(const char *path) {
    int fd = open(path, O_RDONLY);
    if (fd < 0) { perror("Error opening dictionary"); exit(EXIT_FAILURE); }

    char *buf = malloc(BUFSIZE);
    if (!buf) { perror("malloc"); close(fd); exit(EXIT_FAILURE); }

    int bytes, total = 0, size = BUFSIZE;
    while ((bytes = read(fd, buf + total, size - total - 1)) > 0) {
        total += bytes;
        if (total >= size - 1) {
            size *= 2;
            char *tmp = realloc(buf, size);
            if (!tmp) { perror("realloc"); free(buf); close(fd); exit(EXIT_FAILURE); }
            buf = tmp;
        }
    }
    if (bytes < 0) { perror("read"); free(buf); close(fd); exit(EXIT_FAILURE); }

    buf[total] = '\0';
    close(fd);
    return buf;
}

// Convert dictionary buffer to array
int buff_to_array(char *buf, char *dict[]) {
    int numb_words = 0;
    char *token = strtok(buf, "\n");
    while (token && numb_words < TOTAL_WORDS) {
        dict[numb_words++] = token;
        token = strtok(NULL, "\n");
    }
    return numb_words;
}

// Compare function for sorting
int cmp(const void *a, const void *b) {
    return strcasecmp(*(const char **)a, *(const char **)b);
}

// Trim leading brackets and trailing symbols into a separate buffer
void trim_word_copy(const char *src, char *dest) {
    int start = 0, end = strlen(src) - 1;

    while (start <= end && strchr("([{\"'", src[start]) != NULL) start++;
    while (end >= start && !isalnum(src[end])) end--;

    if (start > end) { dest[0] = '\0'; return; }

    int len = end - start + 1;
    memcpy(dest, src + start, len);
    dest[len] = '\0';
}

// Check word has at least one letter
int is_valid_word(const char *word) {
    for (int i = 0; word[i]; i++)
        if (isalpha(word[i])) return 1;
    return 0;
}

// Full capitalization match
int match_word_fullcase(const char *word, const char *dict_word) {
    int len_w = strlen(word);
    int len_d = strlen(dict_word);
    if (len_w != len_d) return 0;

    for (int i = 0; i < len_d; i++) {
        if (isupper(dict_word[i])) {
            if (word[i] != dict_word[i]) return 0;
        } else {
            if (tolower(word[i]) != dict_word[i] && toupper(word[i]) != dict_word[i])
                return 0;
        }
    }
    return 1;
}

// Binary search in dictionary
int word_match_in_dict(const char *word, char *dict[], int numb_words) {
    int low = 0, high = numb_words - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (match_word_fullcase(word, dict[mid])) return 1;
        if (strcasecmp(word, dict[mid]) < 0) high = mid - 1;
        else low = mid + 1;
    }
    return 0;
}

// Check words in a file
int check_word_in_file(const char *path, char *dict[], int numb_words) {
    int fd = open(path, O_RDONLY);
    if (fd < 0) { perror(path); return 1; }

    LINES lines;
    lines_init(&lines, fd);
    char *line;
    int error_count = 0;
    int line_number = 1;

    while ((line = lines_next(&lines))) {
        int col = 1, i = 0;
        char word[WORDLEN];

        for (int pos = 0; line[pos]; pos++, col++) {
            if (isalpha(line[pos]) || isdigit(line[pos]) || line[pos] == '-' || line[pos] == '_') {
                if (i < WORDLEN - 1) word[i++] = line[pos];
            } else if (i > 0) {
                word[i] = '\0';
                char trimmed[WORDLEN];
                trim_word_copy(word, trimmed); // copy trimmed word for comparison

                if (is_valid_word(trimmed) && !word_match_in_dict(trimmed, dict, numb_words)) {
                    printf("%s:%d:%d %s\n", path, line_number, col - i, word);
                    error_count++;
                }
                i = 0;
            }
        }

        if (i > 0) { // last word in line
            word[i] = '\0';
            char trimmed[WORDLEN];
            trim_word_copy(word, trimmed);

            if (is_valid_word(trimmed) && !word_match_in_dict(trimmed, dict, numb_words)) {
                printf("%s:%d:%d %s\n", path, line_number, col - i, word);
                error_count++;
            }
        }

        free(line);
        line_number++;
    }

    lines_destroy(&lines);
    close(fd);
    return error_count;
}

int main(int argc, char **argv) {
    if (argc < 2) { fprintf(stderr, "Usage: %s dictionary [files...]\n", argv[0]); return EXIT_FAILURE; }

    char *dict_buf = dictionary(argv[1]);
    char *dictionary_array[TOTAL_WORDS];
    int numb_words = buff_to_array(dict_buf, dictionary_array);
    qsort(dictionary_array, numb_words, sizeof(char*), cmp);

    int errors = 0;

    if (argc == 2) { // read stdin
        char word[WORDLEN];
        while (scanf("%127s", word) == 1) {
            char trimmed[WORDLEN];
            trim_word_copy(word, trimmed);

            if (is_valid_word(trimmed) && !word_match_in_dict(trimmed, dictionary_array, numb_words)) {
                printf("stdin:1:1 %s\n", word);
                errors++;
            }
        }
    } else { // files from command line
        for (int i = 2; i < argc; i++) {
            errors += check_word_in_file(argv[i], dictionary_array, numb_words);
        }
    }

    free(dict_buf);
    return errors ? EXIT_FAILURE : EXIT_SUCCESS;
}
